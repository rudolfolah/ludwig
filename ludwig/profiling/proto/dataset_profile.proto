// To generate compiled proto code, run:
//   (if protoc not installed yet)
//   > sudo apt install protobuf-compiler
//   > go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
//   > go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
//   > export PATH="$PATH:$(go env GOPATH)/bin"
//
//   Regenerate generated code.
//   > protoc --proto_path=. --python_out=. \
//       ludwig/profiling/proto/whylogs_messages.proto ludwig/profiling/proto/dataset_profile.proto
//   > protoc --go_out=. ludwig/profiling/proto/whylogs_messages.proto ludwig/profiling/proto/dataset_profile.proto
//
// Read more on proto compilation: https://developers.google.com/protocol-buffers/docs/reference/python-generated

// Now run the compiler, specifying the source directory (where your application's source code lives – the current directory is used if you don't provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you would invoke:

// protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto
// Because you want Go code, you use the --go_out option – similar options are provided for other supported languages.
// This generates github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go in your specified destination directory.

syntax = "proto3";

package dataset_profile;

import "ludwig/profiling/proto/whylogs_messages.proto";

option go_package = "github.com/ludwig-ai/ludwig/dataset_profile";


// Dataset profile represents a collection of in-memory profiling stats for a
// dataset. Used for recommending Ludwig configs and Ludwig data type inference.
message DatasetProfile {
  // When the profile was calculated.
  int64 timestamp = 1;

  // The number of examples in this dataset.
  int64 num_examples = 2;

  // The total size of this dataset in bytes.
  int64 size_bytes = 3;

  // Map of feature name to FeatureProfile.
  map<string, FeatureProfile> feature_profiles = 20;
}

// Feature profile represents a collection of in-memory profiling stats for a
// single feature column.
message FeatureProfile {
  // Whylogs metrics.
  // optional whylogs.ColumnMessage whylogs_metrics = 1;
  ColumnMessage whylogs_metrics = 1;

  // Any additional metrics that are not easily captured by whylogs's custom
  // metrics framework. I don't anticipate this being a real issue, but using
  // a sub-message gives us extra insurance for reimplementation and
  // customizability if it comes down to that.
}
